{% extends 'base.html' %}
{% block title %}Lecture Challenge – {{ ch.title }}{% endblock %}

{% block extra_head %}
{{ super() }}
<!-- CodeMirror CSS -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.css">
<!-- Light + Dark themes (we switch in JS) -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/theme/eclipse.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/theme/material.min.css">

<style>
  /* Theme-aware colors for the output pane and message types */
  :root {
    --panel-bg: #f6f8fa;
    --panel-text: #24292f;
    --panel-border: #d0d7de;
    --stdout: #0b7a0b;
    --stderr: #b00020;
    --system: #6b7280;
  }
  [data-theme="dark"] {
    --panel-bg: #0b1020;
    --panel-text: #e8e8f2;
    --panel-border: #30363d;
    --stdout: #a6e22e;
    --stderr: #ff6b6b;
    --system: #9ca3af;
  }

  .row {
    display: flex;
    align-items: flex-start;
    gap: 1rem;
    margin-block: .75rem;
  }
  /* CodeMirror container */
  .CodeMirror {
    flex: 1;
    border: 1px solid var(--panel-border);
    border-radius: 12px;
    font-size: 14px;
    height: 400px !important;   /* start tall */
    min-height: 400px !important;
    resize: both;               /* allow drag-resize */
    overflow: auto;             /* required for resize to work */
    background: var(--panel-bg);
    color: var(--panel-text);
  }
  .controls {
    display: flex;
    flex-direction: column;
    gap: .5rem;
    min-width: 140px;
  }
  .output-box {
    border: 1px solid var(--panel-border);
    border-radius: 12px;
    padding: 12px;
    min-height: 200px;
    background: var(--panel-bg);
    color: var(--panel-text);
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    font-size: 14px;
    overflow: auto;
    resize: both;               /* allow drag-resize */
    white-space: pre-wrap; /* preserve \n as line breaks */
  }
  .stdout { color: var(--stdout); }
  .stderr { color: var(--stderr); }
  .system { color: var(--system); }
  button {
    padding: .6rem 1rem;
    border: 0;
    border-radius: 999px;
    cursor: pointer;
  }
  .primary { background: #2151ff; color:#fff; }
  .ghost { background: #eee; }
  .muted { color:#666; font-size:.9rem; }
  .panel { background: var(--bg); color: var(--text); border:1px solid rgba(0,0,0,.12); border-radius: 12px; }
  #output { margin:0; padding:.75rem; white-space: pre-wrap; min-height:120px; border:1px solid rgba(0,0,0,.15); border-radius: 8px; }
  .toolbar button { /* keeps your buttons visually consistent */ padding:.45rem .9rem; }
  .output-box, #output {
    box-shadow: 0 1px 2px rgba(0,0,0,.04), 0 4px 12px rgba(0,0,0,.06);
  }

</style>
{% endblock %}



{% block content %}
<div class="container">
  <h1>{{ ch.title }}</h1>
  <article class="prompt markdown-body">{{ ch.prompt_md|safe }}</article>

  <div class="editor-wrap">
    <div class="toolbar">
      <button id="runBtn">Run</button>
      <button id="submitBtn" {% if not ch.is_open %}disabled{% endif %}>Submit</button>
      <span class="status" id="statusText"></span>
    </div>
    <div id="studentStatus" class="panel" style="margin-top:.5rem;display:none;">
      <div class="panel-title">Submission Status</div>
      <div id="studentStatusBody" style="padding:.6rem;"></div>
    </div>

	    <textarea id="code" style="display:none;"># Start here…</textarea>
<div id="codeEditor" style="border-top:1px solid rgba(0,0,0,.08);"></div>

<!--    <textarea id="code" spellcheck="false"># Start here…
	print('hello lecture')</textarea> -->
  </div>

  <div class="panel">
    <div class="panel-title">Output</div>
    <pre id="output"></pre>
  </div>

  <div class="io-grid">
    {% if ch.show_leaderboard %}
    <div class="panel">
      <div class="panel-title">Leaderboard</div>
      <ol id="leaderboard" class="lb"></ol>
    </div>
    {% endif %}
    <div class="panel">
      <div class="panel-title">Published Replays</div>
      <div id="replays"></div>
    </div>
  </div>

<!-- Inline Replay Viewer (hidden until "Preview") -->
<div id="replay-viewer" style="display:none;" class="border rounded p-2 mb-3">
  <div class="flex items-center justify-between mb-2">
    <div class="text-sm text-muted">
      <strong>Previewing replay</strong> · <span id="rv-meta"></span>
    </div>
    <div class="flex gap-2">
      <button id="rv-load" class="btn btn-primary">Load into editor</button>
      <button id="rv-close" class="btn btn-secondary">Close</button>
    </div>
  </div>
  <label class="block text-sm font-semibold mb-1">Replay code (read-only)</label>
  <div id="rv-editor" class="border rounded" style="height: 260px;"></div>
  <label class="block text-sm font-semibold mt-2 mb-1">Replay last run output</label>
  <pre id="rv-output" class="border rounded p-2" style="max-height: 160px; overflow:auto; white-space: pre-wrap;"></pre>
</div>

<!-- Recovery bar (appears if there is a backup) -->
<div id="recovery-bar" style="display:none;" class="border rounded p-2 bg-amber-50">
  <div class="flex items-center justify-between">
    <div class="text-sm">
      A previous version of your code was auto-saved (<span id="recovery-when"></span>).
    </div>
    <div class="flex gap-2">
      <button id="recovery-restore" class="btn btn-success">Restore my code</button>
      <button id="recovery-dismiss" class="btn btn-secondary">Dismiss</button>
    </div>
  </div>
</div>

</div>
{% endblock %}

{% block extra_scripts %}
{{ super() }}
<!-- CodeMirror (same versions as your weekly challenge is fine) -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/theme/eclipse.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/theme/material.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/python/python.min.js"></script>
<script>
const slug = {{ ch.slug|tojson }};
let keystrokes = [];
let startTime = null;

const outEl = document.getElementById('output');
const statusEl = document.getElementById('statusText');

// --- CodeMirror init (matches weekly/sandbox) ---
function cmThemeFromPage() {
  return document.documentElement.getAttribute('data-theme') === 'dark' ? 'material' : 'eclipse';
}
const cm = CodeMirror(document.getElementById('codeEditor'), {
  value: document.getElementById('code').value,
  mode: 'python',
  theme: cmThemeFromPage(),
  lineNumbers: true,
  indentUnit: 4,
  viewportMargin: Infinity,
});
new MutationObserver((muts) => {
  for (const m of muts) if (m.attributeName === 'data-theme') cm.setOption('theme', cmThemeFromPage());
}).observe(document.documentElement, { attributes: true });

// Recorder hooks -> keep your keystroke replay
function recordEvent(type, data){
  const t = Date.now() - (startTime ?? (startTime = Date.now()));
  keystrokes.push({ t, type, data });
}
cm.on('change', () => recordEvent('input', { value: cm.getValue() }));
cm.on('keydown', (_, e) => recordEvent('keydown', { key: e.key }));

// --- Pyodide Worker Hook (same message contract you used before) ---
let PY_WORKER = null;
let REQ_ID = 0;

function spawnWorker() {
  if (PY_WORKER) { try { PY_WORKER.terminate(); } catch(e) {} }
  PY_WORKER = new Worker("/static/js/py_runner_worker.js");
  return PY_WORKER;
}
spawnWorker();

async function runPython(code) {
  const id = ++REQ_ID;
  const w = PY_WORKER || spawnWorker();
  const reply = new Promise((resolve) => {
    const handler = (e) => { if (e.data && e.data.id === id) { w.removeEventListener("message", handler); resolve(e.data); } };
    w.addEventListener("message", handler);
    w.postMessage({ id, code });
  });
  const TIMEOUT_MS = 12000;
  const timeout = new Promise((resolve) => {
    setTimeout(() => { try { w.terminate(); } catch(e) {} spawnWorker(); resolve({ ok:false, timeout:true, error:"Time limit exceeded (12s)." }); }, TIMEOUT_MS);
  });
  const res = await Promise.race([reply, timeout]);
  let stdout = "", runtime = 0;
  if (res.ok) {
    stdout = (res.stdout || "").replace(/\r\n/g, "\n");
    runtime = res.runtime_ms || 0;
    outEl.textContent = [stdout, res.stderr].filter(Boolean).join("\n");
  } else {
    outEl.textContent = res.timeout ? res.error : ("Error: " + (res.error || "Unknown error"));
  }
  return { stdout, runtime_ms: runtime };
}

// Leaderboard + replays + my status
async function refreshLeaderboard(){
  const r = await fetch(`/api/lecture/${slug}/leaderboard`);
  const j = await r.json();
  const lb = document.getElementById('leaderboard'); lb.innerHTML = '';
  if(!j.ok) return;
  j.entries.forEach((e,i)=>{
    const li = document.createElement('li'); li.textContent = `${e.display_name}`; lb.appendChild(li);
  });
}
//async function refreshReplays(){
//  const r = await fetch(`/api/lecture/${slug}/replays`);
//  const j = await r.json();
//  const box = document.getElementById('replays'); box.innerHTML = '';
//  if(!j.ok) return;
//  j.items.forEach(item=>{
//    const row = document.createElement('div'); row.className='replay-item'; row.innerHTML = `<span>${item.display_name}</span>`;
//    const btn = document.createElement('button'); btn.textContent = 'Replay';
//    btn.onclick = async ()=>{
//      const rr = await fetch(`/api/lecture/submission/${item.submission_id}/replay`);
//      const jj = await rr.json(); if(!jj.ok) return;
//      const ks = jj.keystrokes ? JSON.parse(jj.keystrokes) : null;
//      cm.setValue((ks && ks.length) ? (ks[ks.length-1].data?.value ?? jj.code) : jj.code);
//      outEl.textContent = jj.run_output || '';
//      statusEl.textContent = `Loaded replay from ${jj.meta.display_name}`;
//    };
//    row.appendChild(btn); box.appendChild(row);
//  });
//}
async function fetchMyStatus() {
  const r = await fetch(`/api/lecture/${slug}/my_status`);
  const j = await r.json();
  const box = document.getElementById('studentStatus');
  const body = document.getElementById('studentStatusBody');
  if (!j.ok || !j.status) { box.style.display = 'none'; return; }
  box.style.display = 'block';
  body.innerHTML = `
    <b>Status:</b> ${j.status.toUpperCase()}${j.points != null ? ` — <b>${j.points} pts</b>` : ''}<br>
    ${j.feedback ? `<b>Feedback:</b> ${j.feedback.replaceAll('\\n','<br>')}` : ''}
    <div style="opacity:.8;margin-top:.25rem;">Last updated: ${new Date(j.updated_at || j.submitted_at).toLocaleString()}</div>
  `;
}
//function startPolling(){ setInterval(()=>{ refreshLeaderboard(); refreshReplays(); fetchMyStatus(); }, 10000); }
function startPolling(){ setInterval(()=>{ refreshLeaderboard(); fetchMyStatus(); }, 10000); }
// Buttons
document.getElementById('runBtn').addEventListener('click', async ()=>{
  const { stdout, runtime_ms } = await runPython(cm.getValue());
  statusEl.textContent = `Ran in ${runtime_ms} ms`;
});

function fetchWithTimeout(url, opts={}, ms=12000){
  const c = new AbortController();
  const id = setTimeout(()=>c.abort(), ms);
  return fetch(url, { ...opts, signal: c.signal }).finally(()=>clearTimeout(id));
}

document.getElementById('submitBtn').addEventListener('click', async ()=>{
  statusEl.textContent = 'Submitting…';
  try {
    const { stdout, runtime_ms } = await runPython(cm.getValue());
    const payload = {
      code: cm.getValue(),
      keystrokes: JSON.stringify(keystrokes),
      run_output: stdout,
      runtime_ms
    };
    const r = await fetchWithTimeout(`/api/lecture/${slug}/submit`, {
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body: JSON.stringify(payload)
    }, 12000);
    const text = await r.text();
    let j = {}; try { j = JSON.parse(text); } catch {}
    if (!r.ok || j.ok === false) {
      statusEl.textContent = `Submit failed: ${j.error || text || r.status}`;
    } else {
      statusEl.textContent = 'Submitted! Waiting for instructor review.';
      refreshLeaderboard(); fetchMyStatus();
    }
  } catch (e) {
    statusEl.textContent = `Network/timeout during submit`;
  }
});


// Initial load
//refreshLeaderboard(); refreshReplays(); fetchMyStatus(); startPolling();
refreshLeaderboard(); fetchMyStatus(); startPolling();
</script>
<script>
(function(){
  // URLs from Flask
  const slug         = {{ ch.slug|tojson }};
  const netid        = {{ netid|default('', true)|tojson }};
  const replaysUrl   = `/api/lecture/{{ ch.slug }}/replays`; 

  // UI elements
  const replaysBox   = document.getElementById('replays');
  const rv           = document.getElementById('replay-viewer');
  const rvMeta       = document.getElementById('rv-meta');
  const rvOutput     = document.getElementById('rv-output');
  const rvCloseBtn   = document.getElementById('rv-close');
  const rvLoadBtn    = document.getElementById('rv-load');
  const rvEditorHost = document.getElementById('rv-editor');
  const recoverBar   = document.getElementById('recovery-bar');
  const recoverWhen  = document.getElementById('recovery-when');
  const restoreBtn   = document.getElementById('recovery-restore');
  const dismissBtn   = document.getElementById('recovery-dismiss');

  // Keys for localStorage backup
  const LS_KEY = `replayBackup:${slug}:${netid}`;

  // Access your main CodeMirror instance (cm/editor) safely
  function getCM(){
    return (window.cm || window.editor || null);
  }
  function getCurrentCode(){
    const cm = getCM();
    if (cm && typeof cm.getValue === 'function') return cm.getValue();
    // Fallback: textarea with id="code" if you still keep it
    const ta = document.getElementById('code');
    return ta ? ta.value : '';
  }
  function setCurrentCode(txt){
    const cm = getCM();
    if (cm && typeof cm.setValue === 'function') { cm.setValue(txt || ''); return; }
    const ta = document.getElementById('code');
    if (ta) ta.value = txt || '';
  }
  function setOutput(txt){
    const out = document.getElementById('output');
    if (out) out.textContent = txt || '';
  }

  // Backup + restore
  function backupCurrentCode(reason){
    try{
      const payload = {
        code: getCurrentCode(),
        reason: reason || 'manual',
        ts: Date.now()
      };
      localStorage.setItem(LS_KEY, JSON.stringify(payload));
      showRecoveryBar(payload);
    }catch(e){ console.warn('backup failed', e); }
  }
  function loadBackup(){
    try{
      const raw = localStorage.getItem(LS_KEY);
      if (!raw) return null;
      return JSON.parse(raw);
    }catch{ return null; }
  }
  function showRecoveryBar(payload){
    if (!payload) payload = loadBackup();
    if (!payload) return;
    const d = new Date(payload.ts);
    recoverWhen.textContent = d.toLocaleString();
    recoverBar.style.display = '';
  }
  function hideRecoveryBar(){
    recoverBar.style.display = 'none';
  }

  restoreBtn?.addEventListener('click', ()=>{
    const payload = loadBackup();
    if (!payload) return;
    setCurrentCode(payload.code || '');
    hideRecoveryBar();
  });
  dismissBtn?.addEventListener('click', hideRecoveryBar);

  // Inline replay viewer state
  let rvCM = null;     // read-only CodeMirror for preview
  let rvData = null;   // last fetched replay json

  function ensureRvCM(){
    if (rvCM) return rvCM;
    // Spin up a read-only CodeMirror in the preview box (use same CM already loaded on the page)
    rvCM = CodeMirror(rvEditorHost, {
      value: '',
      mode: 'python',
      lineNumbers: true,
      readOnly: 'nocursor',
      indentUnit: 4
    });
    rvCM.setSize(null, '100%');
    return rvCM;
  }

  async function previewReplay(sid){
    try{
      // Load from your existing JSON replay endpoint
      const url = `/api/lecture/submission/${sid}/replay`;
      const res = await fetch(url, {headers:{'Accept':'application/json'}});
      const data = await res.json();
      if (!data.ok) throw new Error('Replay load failed');

      rvData = data;  // save for "Load into editor"
      const cm = ensureRvCM();
      cm.setValue(data.code || '');
      rvOutput.textContent = data.run_output || '';
      rvMeta.textContent = `id ${sid}`;
      rv.style.display = '';
      // scroll into view (nicely)
      rv.scrollIntoView({behavior:'smooth', block:'center'});
    }catch(e){
      console.error(e);
      alert('Unable to load replay.');
    }
  }

  rvCloseBtn?.addEventListener('click', ()=>{
    rv.style.display = 'none';
    rvData = null;
  });

  rvLoadBtn?.addEventListener('click', ()=>{
    if (!rvData) return;
    // 1) backup current code (so “Restore my code” works)
    backupCurrentCode('replay-load');
    // 2) replace editor content/output with the replay
    setCurrentCode(rvData.code || '');
    setOutput(rvData.run_output || '');
    // 3) keep the preview open (or close if you prefer)
    // rv.style.display = 'none';
  });

  // Render the Published Replays list with PREVIEW + LOAD buttons
  async function loadReplays(){
    if (!replaysBox) return;
    try{
      const res = await fetch(replaysUrl, {headers:{'Accept':'application/json'}});
      if (!res.ok){
        replaysBox.innerHTML = `<div class="text-sm text-danger">Failed to load replays (HTTP ${res.status}).</div>`;
        return;
      }
      const data = await res.json();
      const items = data.items || [];
      if (!items.length){
        replaysBox.innerHTML = '<div class="text-sm text-muted">No public replays yet.</div>';
        return;
      }
      replaysBox.innerHTML = '<ul class="space-y-1">' + items.map(i => {
        const when = new Date(i.submitted_at).toLocaleString();
        return `
          <li class="flex items-center gap-2">
            <span class="text-sm">${i.netid}</span>
            <span class="text-xs text-muted">${when}</span>
            <button class="btn btn-secondary btn-sm" data-preview="${i.submission_id}">Preview</button>
            <button class="btn btn-primary btn-sm" data-load="${i.submission_id}">Load into editor</button>
          </li>`;
      }).join('') + '</ul>';

      replaysBox.querySelectorAll('[data-preview]').forEach(btn=>{
        btn.addEventListener('click', ()=> previewReplay(btn.getAttribute('data-preview')));
      });
      replaysBox.querySelectorAll('[data-load]').forEach(btn=>{
        btn.addEventListener('click', async ()=>{
          const sid = btn.getAttribute('data-load');
          // If not previewed yet, fetch once, then load
          if (!rvData || (rvMeta.textContent !== `id ${sid}`)){
            await previewReplay(sid);
          }
          rvLoadBtn.click();
        });
      });
    }catch(e){
      console.error(e);
      replaysBox.innerHTML = '<div class="text-sm text-danger">Failed to load replays (JS error).</div>';
    }
  }

  // On load: show recovery bar if a backup exists + fetch replays
  if (loadBackup()) showRecoveryBar();
  document.addEventListener('DOMContentLoaded', loadReplays);
})();
</script>

{% endblock %}

