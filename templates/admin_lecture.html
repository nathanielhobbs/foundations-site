{% extends "base.html" %}
{% block title %}Admin · {{ ch.title }}{% endblock %}

{% block content %}
<h1 class="page-title">Lecture Admin — {{ ch.title }}</h1>

<div class="mb-3 flex items-center gap-3">
  <label class="inline-flex items-center gap-1">
    <input type="checkbox" id="toggleLeaderboard" {{ 'checked' if ch.show_leaderboard else '' }}>
    <span>Show leaderboard on student page</span>
  </label>
  <span id="settingsStatus" class="text-sm text-muted"></span>
</div>

<div class="mb-3 flex items-center gap-3">
  <label class="inline-flex items-center gap-1">
    <input type="checkbox" id="toggleHistory" {{ 'checked' if ch.history_enabled else '' }}>
    <span>Students can view after it closes</span>
  </label>
  <span id="settingsStatusHistory" class="text-sm text-muted"></span>
</div>

	<style>
	  .grid-2 { display:grid; grid-template-columns: 1fr 1fr; gap: 16px; }
	  .stack  { display:flex; flex-direction:column; gap: 8px; }
	  .row    { display:flex; align-items:center; gap: 10px; flex-wrap: wrap; }
	  .muted  { color: #666; font-size: 0.9rem; }
	  fieldset { border:1px solid #ddd; border-radius:10px; padding:12px 14px; }
	  legend   { padding:0 6px; font-weight:600; }
	  .btn     { border:1px solid #ccc; border-radius:10px; padding:6px 10px; background:#f7f7f7; cursor:pointer; }
	  .btn-primary { background:#eef5ff; border-color:#bcd2ff; }
	  .btn-danger  { background:#ffecec; border-color:#ffb3b3; }
	  .spacer { flex:1; }
	  .tick   { margin-left:8px; color:#058d2b; font-size:0.9rem; }
	</style>

	<div class="grid-2">
	  <!-- Sections -->
	  <fieldset class="stack">
	    <legend>Audience</legend>
	    <div class="row">
	      <label><input type="checkbox" id="allSections"> All sections</label>
	      <span class="muted">If checked, everyone can access & submit during the open window.</span>
	    </div>
	    <div class="row" id="sectionChecks">
	      <!-- Update the labels to your real section names if needed -->
	      <label><input type="checkbox" class="secBox" value="1"> Sec 1</label>
	      <label><input type="checkbox" class="secBox" value="2"> Sec 2</label>
	      <label><input type="checkbox" class="secBox" value="5"> Sec 5</label>
	      <label><input type="checkbox" class="secBox" value="6"> Sec 6</label>
	    </div>
	    <div class="muted">Tip: “All sections” overrides any specific section selections.</div>
	    <div class="mb-3 flex items-center gap-3">
		    <!--
		  <label class="inline-flex items-center gap-1">
		    <input type="checkbox" id="toggleReplayScope" {{ 'checked' if ch.replays_same_section_only else '' }}>
		    <span>Limit public replays to same section</span>
		  </label>
		    -->
		    <label style="display:inline-flex; gap:.5rem; align-items:center">
		  <input id="limitReplaysSameSection" type="checkbox"
			 checked="{{ 'checked' if replays_scope else '' }}">
		  Limit public replays to the same section
		</label>

		  <span id="settingsStatusReplayScope" class="text-sm text-muted"></span>
		</div>
		<script>
		(function(){
		  const slug = {{ ch.slug|tojson }};
		  const box  = document.getElementById('limitReplaysSameSection');
		  const msg  = document.getElementById('settingsStatusReplayScope');
		  box.addEventListener('change', async ()=>{
		    msg.textContent = 'Saving…';
		    const res = await fetch(`/api/admin/lecture/${slug}/settings`,{
		      method:'PATCH', headers:{'Content-Type':'application/json'},
		      body: JSON.stringify({ replays_same_section_only: box.checked })
		    });
		    const ok = (await res.json()).ok;
		    msg.textContent = ok ? 'Saved ✓' : 'Save failed';
		    setTimeout(()=> msg.textContent='', 900);
		  });
		})();
		</script>

	  </fieldset>

	  <!-- Availability -->
	  <fieldset class="stack">
	    <legend>Availability</legend>
	    <div class="row">
	      <label class="stack" style="flex:1;">
		<span>Opens at</span>
		<input id="openAt" type="datetime-local" class="border rounded px-2 py-1"
		       value="{{ ch.open_at.strftime('%Y-%m-%dT%H:%M') if ch.open_at else '' }}">
	      </label>
	      <label class="stack" style="flex:1;">
		<span>Closes at</span>
		<input id="closeAt" type="datetime-local" class="border rounded px-2 py-1"
		       value="{{ ch.close_at.strftime('%Y-%m-%dT%H:%M') if ch.close_at else '' }}">
	      </label>
	    </div>
	    <div class="row">
	      <label><input type="checkbox" id="isOpen" {{ 'checked' if ch.is_open else '' }}> Open now</label>
	      <span class="muted">Acts as a manual gate in addition to the window.</span>
	      <span id="saveStatus" class="tick" style="display:none;">Saved ✓</span>
	    </div>
	    <div class="row">
	      <button id="saveWindow" class="btn btn-primary">Save settings</button>
	      <span class="muted">Saves sections, window, and “Open now”.</span>
	    </div>
	    <div class="row">
		  <button type="button" class="btn" id="open5">Open 5 min</button>
		  <button type="button" class="btn" id="open10">Open 10 min</button>
		  <button type="button" class="btn" id="closeNow">Close now</button>
		  <span id="countdown" class="muted"></span>
		</div>
	  </fieldset>
	</div>

	<!-- Danger zone -->
	<fieldset style="margin-top:16px;">
	  <legend>Danger zone</legend>
	  <div class="row">
	    <div class="muted">Deletes this challenge and all of its submissions.</div>
	    <div class="spacer"></div>
	    <button id="deleteBtn" class="btn btn-danger">Delete challenge…</button>
	  </div>
	</fieldset>

	<script>
	(function(){
	  const slug    = {{ ch.slug|tojson }};
	  const openAt  = document.getElementById('openAt');
	  const closeAt = document.getElementById('closeAt');
	  const isOpen  = document.getElementById('isOpen');
	  const saveBtn = document.getElementById('saveWindow');
	  const status  = document.getElementById('saveStatus');
	  const delBtn  = document.getElementById('deleteBtn');

	  const allSections = document.getElementById('allSections');
	  const secBoxes    = Array.from(document.querySelectorAll('.secBox'));

	  // --- Initialize section checkboxes from current value ---
	  (function hydrateSections(){
	    // Server sends ch.section_scope as string like "1,2,6", "ALL", empty, or None.
	    const raw = {{ (ch.section_scope or '')|tojson }};
	    const norm = (raw || '').trim().toUpperCase();
	    if (!norm || norm === 'ALL' || norm === '*') {
	      allSections.checked = true;
	      toggleSpecifics(true);
	    } else {
	      const set = new Set(norm.split(',').map(s => s.trim()));
	      secBoxes.forEach(cb => cb.checked = set.has(String(cb.value).toUpperCase()));
	      allSections.checked = false;
	      toggleSpecifics(false);
	    }
	  })();

	  function toggleSpecifics(allOn){
	    secBoxes.forEach(cb => { cb.disabled = allOn; });
	  }

	  allSections.addEventListener('change', e => {
	    const allOn = e.target.checked;
	    toggleSpecifics(allOn);
	    if (allOn) secBoxes.forEach(cb => cb.checked = false);
	  });

	  // --- Save settings (sections + window + is_open) ---
	  async function saveAll(){
	    // sections
	    let section_scope = null;
	    if (allSections.checked) {
	      section_scope = 'ALL';
	    } else {
	      const vals = secBoxes.filter(cb => cb.checked).map(cb => cb.value);
	      section_scope = vals.length ? vals : []; // backend accepts list or 'ALL'
	    }

	    const payload = {
	      is_open: !!isOpen.checked,
	      open_at: openAt.value || null,
	      close_at: closeAt.value || null,
	      section_scope
	    };
	    payload.replays_same_section_only = document.getElementById('limitReplaysSameSection').checked;

	    status.style.display = 'none';
	    saveBtn.disabled = true;
	    try {
	      const res = await fetch(`/api/admin/lecture/${slug}/settings`, {
		method:'PATCH',
		headers:{'Content-Type':'application/json'},
		body: JSON.stringify(payload)
	      });
	      const data = await res.json().catch(()=>({ok:false}));
	      if (data && data.ok) {
		status.style.display = '';
		setTimeout(()=> status.style.display='none', 1200);
	      } else {
		alert('Save failed.');
	      }
	    } catch(e){
	      alert('Network error while saving.');
	    } finally {
	      saveBtn.disabled = false;
	    }
	  }
	  saveBtn.addEventListener('click', saveAll);

	  // --- Delete ---
	  delBtn.addEventListener('click', async ()=>{
	    if (!confirm('Delete this challenge and all submissions? This cannot be undone.')) return;
	    const res = await fetch(`/api/admin/lecture/${slug}`, { method:'DELETE' });
	    const data = await res.json().catch(()=>({ok:false}));
	    if (data.ok) location.href = '/admin/lecture/';
	    else alert('Delete failed.');
	  });
	})();
	</script>


  <div class="text-sm text-muted mt-1" id="sectionsSaveStatus"></div>
</div>

<!--
<script>
const toggleHistory = document.getElementById('toggleHistory');
const sectionInput  = document.getElementById('sectionInput');
const settingsStatus = document.getElementById('settingsStatus');

async function saveSettings(patch){
  settingsStatus.textContent = 'Saving…';
  const res = await fetch(`/api/admin/lecture/{{ ch.slug }}/settings`, {
    method:'PATCH', headers:{'Content-Type':'application/json'},
    body: JSON.stringify(patch)
  });
  settingsStatus.textContent = (await res.json()).ok ? 'Saved ✓' : 'Save failed';
  setTimeout(()=>settingsStatus.textContent='', 900);
}

toggleHistory.addEventListener('change', ()=> saveSettings({ history_enabled: toggleHistory.checked }));
sectionInput.addEventListener('change', ()=> {
  const raw = sectionInput.value.trim();
  // You can accept "ALL" or "1,2,6"
  saveSettings({ section_scope: raw || 'ALL' });
});
</script>
-->

<!-- 3-column layout: Queue | Code/Output | Comment -->
<div id="reviewShell"
     style="display:grid; grid-template-columns: 320px 1fr 320px; gap:16px; align-items:stretch;">

  <!-- LEFT: Queue -->
  <aside>
    <div class="flex items-center gap-2 mb-2">
      <select id="filterStatus" class="border rounded px-2 py-1">
        <option value="">All</option>
        <option value="pending" selected>Pending</option>
        <option value="approved">Approved</option>
        <option value="rejected">Rejected</option>
	<option value="replay">Replay</option>
      </select>
      <button id="refreshBtn" class="btn btn-secondary">Refresh</button>
      <span id="queueStatus" class="text-sm text-muted"></span>
    </div>

    <ul id="queue" class="border rounded divide-y"
        style="max-height: 78vh; overflow:auto; margin:0; padding:0; list-style:none;"></ul>
  </aside>

  <!-- MIDDLE: Code + Output (output visible by default) -->
  <main id="reader" class="border rounded p-3" data-selected="" style="min-width:520px; overflow:hidden;">
    <div class="flex items-center justify-between mb-2">
      <div class="truncate">
        <div class="text-sm text-muted">Submission</div>
        <div class="text-lg font-semibold truncate">
          <span id="readerNetid">—</span>
          <span id="readerMeta" class="text-sm text-muted"></span>
        </div>
      </div>
      <div class="flex items-center gap-2">
        <button id="approveBtn" class="btn btn-success">Approve (A)</button>
        <button id="rejectBtn"  class="btn btn-danger">Reject (R)</button>
	<label class="inline-flex items-center gap-1">
	    <input type="checkbox" id="replayChk">
	    <span>Public replay</span>
	  </label>
        <button id="prevBtn"    class="btn btn-secondary">Prev (K)</button>
        <button id="nextBtn"    class="btn btn-primary">Next (J)</button>
      </div>
    </div>

    <label class="block text-sm font-semibold mb-1">Code</label>
    <pre id="codeBox" class="border rounded p-2"
         style="height: 48vh; overflow:auto; white-space: pre; margin-bottom:10px;"></pre>

    <label class="block text-sm font-semibold mb-1">Last run output</label>
    <pre id="outputBox" class="border rounded p-2"
         style="height: 24vh; overflow:auto; white-space: pre-wrap;"></pre>
  </main>

  <!-- RIGHT: Comment (autosaves) -->
  <aside class="border rounded p-3" style="display:flex; flex-direction:column;">
    <div class="text-lg font-semibold mb-2">Comment</div>
    <textarea id="commentBox" class="border rounded w-full p-2" rows="12"
              placeholder="Write brief feedback…"
              style="flex:1; resize:vertical;"></textarea>
    <div class="text-sm text-muted mt-2" id="saveStatus"></div>
    <hr class="my-3">
    <div class="text-sm text-muted">
      <div><strong>Hotkeys</strong>: A=approve, R=reject, J=next, K=prev</div>
    </div>
  </aside>
</div>
{% endblock %}

{% block extra_scripts %}
<script>
	const toggleLeaderboard = document.getElementById('toggleLeaderboard');
	const settingsStatus = document.getElementById('settingsStatus');

	toggleLeaderboard.addEventListener('change', async ()=>{
	  settingsStatus.textContent = 'Saving…';
	  const res = await fetch(`/api/admin/lecture/{{ ch.slug }}/settings`, {
	    method:'PATCH',
	    headers:{'Content-Type':'application/json'},
	    body: JSON.stringify({ show_leaderboard: toggleLeaderboard.checked })
	  });
	  const ok = (await res.json()).ok;
	  settingsStatus.textContent = ok ? 'Saved ✓' : 'Save failed';
	  if (ok) setTimeout(()=> settingsStatus.textContent = '', 800);
	});
</script>

<script>
(function(){
  const slug = {{ ch.slug|tojson }};

  // --- history toggle (separate status span to avoid ID collisions) ---
  const toggleHistory = document.getElementById('toggleHistory');
  const statusHistory = document.getElementById('settingsStatusHistory');
  toggleHistory.addEventListener('change', async ()=>{
    statusHistory.textContent = 'Saving…';
    const res = await fetch(`/api/admin/lecture/${slug}/settings`, {
      method:'PATCH', headers:{'Content-Type':'application/json'},
      body: JSON.stringify({ history_enabled: toggleHistory.checked })
    });
    const ok = (await res.json()).ok;
    statusHistory.textContent = ok ? 'Saved ✓' : 'Save failed';
    setTimeout(()=> statusHistory.textContent='', 900);
  });

  // --- section multi-select ---
  const secAll  = document.getElementById('secAll');
  const secList = document.getElementById('secList');
  const saveMsg = document.getElementById('sectionsSaveStatus');

  // Current scope from server
  const scopeRaw = {{ (ch.section_scope or 'ALL')|tojson }};
  function parseScope(raw){
    if (!raw || String(raw).toUpperCase() === 'ALL') return { all:true, set:new Set() };
    const arr = String(raw).split(',').map(s=>s.trim()).filter(Boolean);
    return { all:false, set:new Set(arr) };
  }
  const current = parseScope(scopeRaw);

  // Apply initial state
  (function init(){
    secAll.checked = !!current.all;
    document.querySelectorAll('#secList .secItem').forEach(cb=>{
      cb.checked = current.all ? false : current.set.has(cb.value);
      cb.disabled = current.all;
    });
  })();

  function payload(){
    if (secAll.checked) return { section_scope: 'ALL' };
    const picked = [];
    document.querySelectorAll('#secList .secItem').forEach(cb=>{
      if (cb.checked) picked.push(cb.value);
    });
    return picked.length ? { section_scope: picked } : { section_scope: 'ALL' };
  }

  async function saveScope(){
    saveMsg.textContent = 'Saving…';
    const res = await fetch(`/api/admin/lecture/${slug}/settings`, {
      method:'PATCH', headers:{'Content-Type':'application/json'},
      body: JSON.stringify(payload())
    });
    const ok = (await res.json()).ok;
    saveMsg.textContent = ok ? 'Saved ✓' : 'Save failed';
    setTimeout(()=> saveMsg.textContent='', 900);
  }

  secAll.addEventListener('change', ()=>{
    const on = secAll.checked;
    document.querySelectorAll('#secList .secItem').forEach(cb=>{
      cb.checked = false;
      cb.disabled = on;
    });
    saveScope();
  });

  secList.addEventListener('change', ()=>{
    secAll.checked = false;
    document.querySelectorAll('#secList .secItem').forEach(cb=> cb.disabled = false);
    saveScope();
  });
})();
</script>


<script>
(function(){
  const slug = {{ ch.slug|tojson }};

  const queueEl      = document.getElementById('queue');
  const readerEl     = document.getElementById('reader');
  const readerNetid  = document.getElementById('readerNetid');
  const readerMeta   = document.getElementById('readerMeta');
  const codeBox      = document.getElementById('codeBox');
  const outputBox    = document.getElementById('outputBox');
  const filterSel    = document.getElementById('filterStatus');
  const refreshBtn   = document.getElementById('refreshBtn');
  const queueStatus  = document.getElementById('queueStatus');
  const approveBtn   = document.getElementById('approveBtn');
  const rejectBtn    = document.getElementById('rejectBtn');
  const nextBtn      = document.getElementById('nextBtn');
  const prevBtn      = document.getElementById('prevBtn');
  const commentBox   = document.getElementById('commentBox');
  const saveStatus   = document.getElementById('saveStatus');

  let items = [];   // [{id, netid, status, comment, created_at}, ...] asc by created_at
  let selectedId = null;

  function iconFor(status){
    return status === 'approved' ? '✅' : (status === 'rejected' ? '❌' : '⏳');
  }
  function setQueueStatus(m){ queueStatus.textContent = m || ''; }
  function setSaveStatus(m){ saveStatus.textContent = m || ''; }

  async function fetchQueue(){
    const qs = new URLSearchParams();
    if (filterSel.value) qs.set('status', filterSel.value);
    const res = await fetch(`/api/admin/lecture/${slug}/submissions?`+qs.toString());
    const data = await res.json();
    if (!data.ok) throw new Error('Queue fetch failed');
    items = (data.items||[]).sort((a,b)=> a.created_at.localeCompare(b.created_at));
    renderQueue();
  }

  function renderQueue(){
	  const keep = selectedId || readerEl.dataset.selected || null;
	  queueEl.innerHTML = items.map((s, idx) => {
	    const isSel = (String(s.id) === String(keep));
	    const when = new Date(s.created_at).toLocaleString();
	    const sec = s.section ? ` (Sec ${s.section})` : '';
	    // one-line preview of feedback, trimmed
	    // const preview = (s.comment || '').split('\n')[0];
	    const preview = (s.student_visible_feedback ?? s.feedback_display ?? '').split('\n')[0];

	    const trimmed = preview.length > 120 ? preview.slice(0, 120) + '…' : preview;
	    const replay = s.public_replay ? ' <span title="Public replay">▶︎</span>' : '';

	    return `<li data-sid="${s.id}" style="padding:8px; cursor:pointer; ${isSel ? 'background:#eef6ff;' : ''}">
	      <div class="flex items-center justify-between">
		<div class="truncate">
		  <span class="text-muted">${idx+1}.</span>
		  ${iconFor(s.status)} <strong>${s.netid}</strong><span class="text-muted">${sec}</span>
		</div>
		<div class="text-xs text-muted">#${s.id}</div>
	      </div>
	      ${ trimmed ? `<div class="text-xs text-muted mt-1 truncate" title="${preview.replace(/"/g,'&quot;')}">${trimmed}</div>` : '' }
	      <div class="text-xs text-muted">${when}</div>
	    </li>`;
	  }).join('');
	}


  const replayChk = document.getElementById('replayChk');

	async function setReplay(sid, value){
	  setSaveStatus('Saving…');
	  const res = await fetch(`/api/admin/lecture/submission/${sid}`, {
	    method:'PATCH',
	    headers:{'Content-Type':'application/json'},
	    body: JSON.stringify({ public_replay: !!value })
	  });
	  const ok = (await res.json()).ok;
	  if (ok){
	    const row = items.find(x=>String(x.id)===String(sid));
	    if (row) row.public_replay = !!value;
	    renderQueue(); // refresh icons/previews
	    setSaveStatus('Saved ✓'); setTimeout(()=>setSaveStatus(''), 700);
	  } else setSaveStatus('Save failed');
	}

	replayChk.addEventListener('change', ()=> {
	  if (selectedId) setReplay(selectedId, replayChk.checked);
	});

  async function loadSubmission(sid){
    try{
      const res = await fetch(`/api/lecture/submission/${sid}/replay`);
      const data = await res.json();
      if (!data.ok) throw new Error('Load failed');
      selectedId = sid;
      readerEl.dataset.selected = sid;
      const row = items.find(x=>String(x.id)===String(sid)) || {};
      replayChk.checked = !!row.public_replay;
      readerNetid.textContent = row.netid || '—';
      readerMeta.textContent  = ` · id ${sid} · ${row.status||''}`;
      codeBox.textContent     = data.code || '';
      outputBox.textContent   = data.run_output || '';
      commentBox.value        = row.comment || '';

      // keep highlight
      [...queueEl.querySelectorAll('li')].forEach(li=>{
        li.style.background = (li.dataset.sid === String(sid)) ? '#eef6ff' : '';
      });
    }catch(e){ console.error(e); }
  }

  function neighbor(delta){
    if (!items.length) return null;
    if (!selectedId){ return items[0]?.id || null; }
    const idx = items.findIndex(x=>String(x.id)===String(selectedId));
    const j = Math.min(items.length-1, Math.max(0, idx + delta));
    return items[j]?.id || null;
  }

  async function setStatus(sid, status){
    setSaveStatus('Saving…');
    const res = await fetch(`/api/admin/lecture/submission/${sid}`, {
      method:'PATCH', headers:{'Content-Type':'application/json'},
      body: JSON.stringify({ status })
    });
    const ok = (await res.json()).ok;
    if (ok){
      const row = items.find(x=>String(x.id)===String(sid));
      if (row){ row.status = status; }
      renderQueue();
      setSaveStatus('Saved ✓'); setTimeout(()=>setSaveStatus(''), 700);
    } else setSaveStatus('Save failed');
  }

  // debounced comment save (autosave)
  let commentTimer = null;
  function scheduleCommentSave(){
    if (!selectedId) return;
    clearTimeout(commentTimer);
    commentTimer = setTimeout(async ()=>{
      setSaveStatus('Saving…');
      const res = await fetch(`/api/admin/lecture/submission/${selectedId}`, {
        method:'PATCH', headers:{'Content-Type':'application/json'},
        body: JSON.stringify({ comment: commentBox.value })
      });
      const ok = (await res.json()).ok;
      if (ok){
        const row = items.find(x=>String(x.id)===String(selectedId));
        if (row) row.comment = commentBox.value;
	renderQueue()
        setSaveStatus('Saved ✓'); setTimeout(()=>setSaveStatus(''), 700);
      } else setSaveStatus('Save failed');
    }, 400);
  }

  // events
  queueEl.addEventListener('click', (e)=>{
    const li = e.target.closest('li[data-sid]');
    if (!li) return;
    loadSubmission(li.dataset.sid);
  });
  approveBtn.addEventListener('click', ()=> { if (selectedId) setStatus(selectedId, 'approved'); });
  rejectBtn .addEventListener('click', ()=> { if (selectedId) setStatus(selectedId, 'rejected'); });
  nextBtn   .addEventListener('click', ()=> { const id = neighbor(+1); if (id) loadSubmission(id); });
  prevBtn   .addEventListener('click', ()=> { const id = neighbor(-1); if (id) loadSubmission(id); });
  commentBox.addEventListener('input', scheduleCommentSave);
  filterSel.addEventListener('change', async ()=>{ await fetchQueue(); if (!selectedId && items.length) loadSubmission(items[0].id); });
  refreshBtn.addEventListener('click', fetchQueue);

  // Hotkeys: A/R/J/K
  window.addEventListener('keydown', (e)=>{
    if (['INPUT','TEXTAREA'].includes((e.target||{}).tagName)) return;
    if (e.key.toLowerCase()==='a'){ if (selectedId) setStatus(selectedId, 'approved'); }
    if (e.key.toLowerCase()==='r'){ if (selectedId) setStatus(selectedId, 'rejected'); }
    if (e.key.toLowerCase()==='j'){ const id = neighbor(+1); if (id) loadSubmission(id); }
    if (e.key.toLowerCase()==='k'){ const id = neighbor(-1); if (id) loadSubmission(id); }
  });

  // quiet poll
  async function poll(){
    const oldScroll = queueEl.scrollTop;
    const keep = selectedId;
    try{
      await fetchQueue();
      if (keep){
        [...queueEl.querySelectorAll('li')].forEach(li=>{
          li.style.background = (li.dataset.sid === String(keep)) ? '#eef6ff' : '';
        });
      }
      queueEl.scrollTop = oldScroll;
      setQueueStatus('');
    }catch(e){
      console.warn(e);
      setQueueStatus('Refresh failed');
    }finally{
      setTimeout(poll, 5000);
    }
  }

  // boot
  (async ()=>{
    await fetchQueue();
    if (items.length) loadSubmission(items[0].id);
    poll();
  })();
})();
</script>
<script>
(function(){
  const slug = {{ ch.slug|tojson }};
  const openAt  = document.getElementById('openAt');
  const closeAt = document.getElementById('closeAt');
  const isOpen  = document.getElementById('isOpen');
  const saveBtn = document.getElementById('saveWindow');
  const msg     = document.getElementById('windowStatus');
  const delBtn  = document.getElementById('deleteBtn');

  async function saveWindow(){
    msg.textContent = 'Saving…';
    const body = {
      is_open: isOpen.checked,
      open_at: openAt.value || null,
      close_at: closeAt.value || null
    };
    body.replays_same_section_only = document.getElementById('limitReplaysSameSection').checked;
    const res = await fetch(`/api/admin/lecture/${slug}/settings`, {
      method:'PATCH', headers:{'Content-Type':'application/json'},
      body: JSON.stringify(body)
    });
    const ok = (await res.json()).ok;
    msg.textContent = ok ? 'Saved ✓' : 'Save failed';
    setTimeout(()=> msg.textContent='', 900);
  }
  saveBtn.addEventListener('click', saveWindow);

  delBtn.addEventListener('click', async ()=>{
    if (!confirm('Delete this challenge and all submissions? This cannot be undone.')) return;
    const res = await fetch(`/api/admin/lecture/${slug}`, { method:'DELETE' });
    const ok = (await res.json()).ok;
    if (ok) location.href = '/admin/lecture/';
    else alert('Delete failed');
  });
})();
</script>

<script>
(function(){
  const slug = {{ ch.slug|tojson }};
  const openAt    = document.getElementById('openAt');
  const closeAt   = document.getElementById('closeAt');
  const isOpen    = document.getElementById('isOpen');
  const btn5      = document.getElementById('open5');
  const btn10     = document.getElementById('open10');
  const closeNow  = document.getElementById('closeNow');
  const countdown = document.getElementById('countdown');
  const tickBadge = document.getElementById('saveStatus'); // the green "Saved ✓" badge

  function pad(n){ return n<10 ? '0'+n : ''+n; }
  function toLocalISO(dt){
    // "YYYY-MM-DDTHH:MM" for <input type="datetime-local">
    return dt.getFullYear()+'-'+pad(dt.getMonth()+1)+'-'+pad(dt.getDate())
         +'T'+pad(dt.getHours())+':'+pad(dt.getMinutes());
  }

  async function autoSave(){
    // show saving state subtly by toggling the badge
    if (tickBadge) tickBadge.style.display = 'none';
    try{
      const body = {
        is_open: !!isOpen.checked,
        open_at: openAt.value || null,
        close_at: closeAt.value || null
      };
      body.replays_same_section_only = document.getElementById('limitReplaysSameSection').checked;
      const res = await fetch(`/api/admin/lecture/${slug}/settings`, {
        method: 'PATCH',
        headers: {'Content-Type':'application/json'},
        body: JSON.stringify(body)
      });
      const data = await res.json().catch(()=>({ok:false}));
      if (data.ok && tickBadge){
        tickBadge.style.display = '';
        setTimeout(()=> tickBadge.style.display = 'none', 1200);
      } else {
        console.warn('Auto-save failed');
      }
    }catch(e){
      console.warn('Network error during auto-save', e);
    }
  }

  function setWindowFor(minutes){
    const now = new Date();
    const end = new Date(now.getTime() + minutes*60*1000);
    openAt.value  = toLocalISO(now);
    closeAt.value = toLocalISO(end);
    isOpen.checked = true;
  }

  btn5.addEventListener('click', async ()=>{
    setWindowFor(5);
    await autoSave();
  });

  btn10.addEventListener('click', async ()=>{
    setWindowFor(10);
    await autoSave();
  });

  closeNow.addEventListener('click', async ()=>{
    closeAt.value = toLocalISO(new Date());
    isOpen.checked = false;
    await autoSave();
  });

  // live countdown
  function tick(){
    if (!closeAt.value){ countdown.textContent=''; return setTimeout(tick, 1000); }
    const end = new Date(closeAt.value);
    const now = new Date();
    const ms  = end - now;
    if (isNaN(ms)){ countdown.textContent=''; return setTimeout(tick, 1000); }
    if (ms <= 0){ countdown.textContent='Closed'; return setTimeout(tick, 1000); }
    const total = Math.floor(ms/1000);
    const m = Math.floor(total/60), s = total%60;
    countdown.textContent = `Time remaining: ${m}:${pad(s)}`;
    setTimeout(tick, 250);
  }
  tick();
})();
</script>

{% endblock %}

